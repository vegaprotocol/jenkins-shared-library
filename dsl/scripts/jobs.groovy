/* groovylint-disable CompileStatic, DuplicateNumberLiteral, DuplicateStringLiteral, LineLength */
// https://github.com/janinko/ghprb/issues/77
def scmDefinition(args){
    return {
        cpsScm {
            scm {
                git {
                    if (args.branch) {
                        branch("*/${args.branch}")
                    }
                    remote {
                        if (args.useGithub) {
                            github(args.repoName)
                        }
                        else {
                            url(args.repo)
                            credentials(args.get('credentials', "vega-ci-bot"))
                            if (args.branch) {
                                refspec("+refs/heads/${args.branch}:refs/remotes/origin/${args.branch}")
                            }
                        }
                    }
                    if (args.check) {
                        extensions {
                            gitSCMChecksExtension {
                                // If this option is checked, verbose log will be output to build console; the verbose log is useful for debugging the publisher creation.
                                verboseConsoleLog(true)
                            }
                            gitSCMStatusChecksExtension {
                                name(args.check)
                                unstableBuildNeutral(true)
                            }
                        }
                    }
                }
            }
            scriptPath(args.get('jenkinsfile', 'Jenkinsfile'))
        }
    }
}

def h(def text, def num=4) {
    return "<h${num}>${text}</h${num}>"
}

def ul(def ulMap) {
    if (ulMap instanceof Map) {
        ulMap = ulMap.collect { "${it.key} - ${it.value}" }
    }
    def entries = ulMap.collect { "<li>${it}</li>" }.join("\n")
    return "<ul>${entries}</ul>"
}


def standardDescription() {
    def url = "https://github.com/vegaprotocol/jenkins-shared-library/tree/main/dsl"
    return h("""
        This job was automatically generated by DSL script located at <a href="${url}">this repository</a> and processed by <a href='${binding.variables.get('JOB_URL')}'>this job</a>, any manual configuration will be overriden.
    """, 5)
}

isNewJenkins = getBinding().getVariables().JENKINS_URL.contains('jenkins.vega.rocks')

def createCommonPipeline(args){
    args.repoName = "vegaprotocol/${args.repo}"
    args.repo = "git@github.com:vegaprotocol/${args.repo}.git"

    def des = args.get('description', '')
    des += "${des ? '<br/>' : ''} ${standardDescription()}"

    return pipelineJob(isNewJenkins ? args.name.replaceAll(' ', '-') : args.name) {
        if (isNewJenkins) {
            displayName(args.name.split('/')[-1])
        }

        disabled(args.get('disabled', !isNewJenkins))

        description(des)

        logRotator {
            daysToKeep(args.daysToKeep ?: 45)
            numToKeep(args.numToKeep ?: 1000)
            artifactDaysToKeep(args.daysToKeep ?: 45)
            artifactNumToKeep(args.numToKeep ?: 1000)
        }

        if (args.parameters) {
            parameters args.parameters
        }

        environmentVariables {
            keepBuildVariables(true)
            keepSystemVariables(true)
            args.env.each { key, value ->
                env(key.toUpperCase(), value)
            }
            env("GOROOT", "/usr/local/go")
            env("GOPATH", "/jenkins/GOPATH")
            env("GOCACHE", "/jenkins/GOCACHE")
            env("GO111MODULE", "on")
            env("GOBIN", "/jenkins/GOPATH/bin")
            env("PATH+EXTRA", "/jenkins/GOPATH/bin:/usr/local/go/bin:/home/ubuntu/.local/bin:/home/ubuntu/.pyenv/bin:/home/ubuntu/.pyenv/shims")
        }

        if (args.get('useScmDefinition', true)) {
            definition scmDefinition(args)
        }
        else {
            definition args.definition
        }

        properties {
            if (args.copyArtifacts) {
                copyArtifactPermission {
                    projectNames('*')
                }
            }
            if (args.disableConcurrentBuilds) {
                disableConcurrentBuilds {
                    abortPrevious(args.abortPrevious ?: false)
                }
            }
            pipelineTriggers {
                triggers {
                    if (args.get('useScmDefinition', true)) {
                        githubPush()
                    }
                    if (args.cron) {
                        cron {
                            spec(args.cron)
                        }
                    }
                    if (args.parameterizedCron) {
                        parameterizedCron {
                            parameterizedSpecification(args.parameterizedCron)
                        }
                    }
                }
            }
        }
    }
}

def libDefinition(methodName) {
    return {
        cps {
            script('''
            library (
                identifier: "vega-shared-library@${env.JENKINS_SHARED_LIB_BRANCH}",
                changelog: false,
            )

            ''' + methodName)
        }
    }
}

def vegavisorParamsBase(args=[:]) {
    return {
        booleanParam('SKIP_INFRA_PROVISION', true, 'switch to false when creating node, or you want to apply other changes along with retarting node. Otherwise you can use non-restart required pipeline.')
        booleanParam('UPDATE_SYSTEM_CONFIGURATION', args.get('UPDATE_CONFIGURATION', true), 'This performs all operations related to system configuration - packages, caddy server file etc. It effect is not dependent on any network action like "restart-network" or "create-node". You can set whatever you want there')
        booleanParam('PERFORM_NETWORK_OPERATIONS', true, 'This perform all operations related to blockchain state - configures data nodes, validators, installs vegavisor, checks block status etc.')
        stringParam('VEGACAPSULE_BRANCH', 'main', 'Git branch, tag or hash of the vegaprotocol/vegacapsule repository')
        stringParam('DEVOPSTOOLS_BRANCH', args.get('DEVOPSTOOLS_BRANCH', 'main'), 'Git branch, tag or hash of the vegaprotocol/devopstools repository')
        stringParam('ANSIBLE_BRANCH', 'master', 'Git branch, tag or hash of the vegaprotocol/ansible repository')
        stringParam('NETWORKS_INTERNAL_BRANCH', 'main', 'Git branch, tag or hash of the vegaprotocol/networks-internal repository')
        stringParam('JENKINS_SHARED_LIB_BRANCH', 'main', 'Branch of jenkins-shared-library from which pipeline should be run')
        stringParam('NODE_LABEL', args.get('NODE_LABEL', 'tiny'), 'Jenkins label for running pipeline (empty means any node)')
    }
}

def vegavisorRestartNetworkParams(args=[:]) {
    def choices = [
        'restart-network': 'regular restart',
        'create-network': 'reset network, additionally runs playbook-barenode-common.yaml that provisions software for nodes',
        'stop-network': 'stop entire network',
    ]
    return vegavisorParamsBase(args) << {
        choiceParam('ACTION', choices.keySet() as List, h('action to be performed with a network') + ul(choices))
        booleanParam('DRY_RUN', false, 'Run dry run without applying changes.')
        stringParam('RELEASE_VERSION', '', 'Specify which version of vega to deploy. Leave empty to restart network only.')
        stringParam('DOCKER_VERSION', '', 'Specify which version of docker images to deploy. Leave empty to not change.')
        booleanParam('UNSAFE_RESET_ALL', true, 'If set to true then delete all local state. Otherwise leave it for restart.')
        booleanParam('USE_CHECKPOINT', args.get('USE_CHECKPOINT', true), 'This will download latest checkpoint and use it to restart the network with')
        booleanParam('CREATE_MARKETS', args.get('CREATE_MARKETS', false), h('create markets'))
        booleanParam('TOP_UP_BOTS', args.get('TOP_UP_BOTS', false), h('trigger top up job'))
        stringParam('DEVOPSSCRIPTS_BRANCH', 'main', 'Git branch, tag or hash of the vegaprotocol/devopsscripts repository')
        stringParam('CHECKPOINT_STORE_BRANCH', 'main', 'Git branch, tag or hash of the vegaprotocol/checkpoint-store repository')
        stringParam('TIMEOUT', '80', 'Number of minutes after which the job will stop')
        stringParam('VEGA_VERSION', '', '''(Use only if you know what you are doing). Specify which version of vega to deploy. Leave empty to restart network only.
        Provide git branch, tag or hash of the vegaprotocol/vega repository or leave empty''')
        stringParam('VEGA_REPO', 'vegaprotocol/vega', 'Works only when VEGA_VERSION is not empty')
    }
}

devopsInfraDocs = h('Please read the docs located <a href="https://github.com/vegaprotocol/devops-infra/blob/master/doc/manage-new-network.md">here</a> on how to manage and debug networks', 2)

def vegavisorManageNodeDescription() {
    return devopsInfraDocs + "<br/>Some popular scenarios to run with this job<br/>" + ul([
        'ansible tag "restart-node" + unsafe_reset_all set to true is restart from block 0 without local snapshot',
        'ansible tag "restart-node" without unsafe_reset_all is restart from local snapshot (due to vegavisor config located in ansible)',
        'ansible tag "create-node" + unsafe_reset_all + use_remote_snapshot + join_as_validator causes node to be reconfigured from 0 and join network as validator ',
    ])
}

def vegavisorManageNodeParams(args=[:]) {
    def choices = [
        'restart-node': 'regular restart',
        'create-node': 'reset node',
        'stop-node': 'stop node',
    ]

    List nodesList = (0..15).collect { "n${it.toString().padLeft( 2, '0' )}.${args.name}.vega.rocks" } + [
        "be.${args.name}.vega.rocks",
        "be02.${args.name}.vega.rocks",
        "metabase00.${args.name}.vega.rocks",
        "metabase01.${args.name}.vega.rocks",
        "metabase02.${args.name}.vega.rocks",
        "m.${args.name}.vega.rocks",
    ]

    if (args.sentryNodes) {
        nodesList += ((0..15).collect { nodeNumber ->
            (0..9).collect { "sn${nodeNumber.toString().padLeft( 2, '0' )}${it}.${args.name}.vega.rocks" }
        }).flatten()
    }


    if (args.name == "mainnetapi") {
        nodesList = [
            "api0.mainnet.vega.xyz",
            "api1.mainnet.vega.xyz",
            "api2.mainnet.vega.xyz",
            "api3.mainnet.vega.xyz",
            "be0.mainnet.vega.xyz",
            "be1.mainnet.vega.xyz",
            "observer-01.mainnet.vega.xyz",
            "observer-02.mainnet.vega.xyz",
        ]
    } else if (args.name == "mainnet") {
        nodesList = [
            "api0.vega.community",
            "api1.vega.community",
            "api2.vega.community",
            "api3.vega.community",
            "api4.vega.community",
            "api5.vega.community",
            "be0.vega.community",
            "be1.vega.community",
            "be3.vega.community",
            "m0.vega.community",
            "m2.vega.community",
            "m3.vega.community",
            "m4.vega.community",
            "metabase.vega.community",
            "test.vega.community",
        ]
    }

    return vegavisorParamsBase(args) << {
        choiceParam('NODE', nodesList, 'Choose which node to restart')
        choiceParam('ACTION', choices.keySet() as List, h('action to be performed with a node') + ul(choices) )
        booleanParam('DRY_RUN', false, 'Run dry run without applying changes.')
        booleanParam('UNSAFE_RESET_ALL', false, 'If set to true then delete all local node state. Otherwise leave it for restart.')
        booleanParam('JOIN_AS_VALIDATOR', false, 'If set to true causes node to join network as validator. It will work only with `create-node`')
        booleanParam('USE_REMOTE_SNAPSHOT', false, 'If set to true uses data from available validator to configure remote snapshot in tendermint config')
        stringParam('USE_REMOTE_SNAPSHOT_BLOCK_HEIGHT', '0', 'If set to any value different than 0 then ansible while omit reading /api/v2/snapshot tendermint API and set --load-from-block-height flag for vega directly from this input')
        booleanParam('RANDOM_NODE', false, 'If set to true restart random node instead of the one provided in the parameters.')
        stringParam('RELEASE_VERSION', '', 'Specify which version of vega to deploy. Leave empty to restart network only.')
        stringParam('TIMEOUT', '40', 'Number of minutes after which the job will stop')
        stringParam('VEGA_VERSION', '', '''(Use only if you know what you are doing). Specify which version of vega to deploy. Leave empty to restart network only.
        Provide git branch, tag or hash of the vegaprotocol/vega repository or leave empty''')
        booleanParam('DISABLE_LOCK', false, 'Use only if you know what you are doing!!! Useful when provisioning many same nodes at the time')
    }
}

def vegavisorProtocolUpgradeParams(args=[:]) {
    return vegavisorParamsBase(args + [
        'UPDATE_CONFIGURATION': false,
    ]) << {
        stringParam('UPGRADE_BLOCK', '', 'Protocol upgrade block. Leave empty to use: current block + 400')
        stringParam('RELEASE_VERSION', '', 'Specify which version of vega to deploy. Leave empty to restart network only.')
        booleanParam('MANUAL_INSTALL', true, 'If true, then config and binaries are uploaded manualy before protocol upgrade. When false, then visor automatically create everything.')
        booleanParam('RENDER_CONFIGS', true, 'If true, new configs are rendered and updated on the servers')
        booleanParam('DRY_RUN', true, 'If true, no action is taken on the network')
        stringParam('TIMEOUT', '40', 'Number of minutes after which the job will stop')
        stringParam('DOCKER_VERSION', '', 'Specify which version of docker images to deploy. Leave empty to not change.')
    }
}

def vegavisorTopupBotsParams(args=[:]) {
    return {
        stringParam('DEVOPSTOOLS_BRANCH', 'main', 'Git branch, tag or hash of the vegaprotocol/devopstools repository')
        stringParam('ADDITIONAL_TRADER_BOTS_IDS', args.get('additionalTraderbotsIds', []).join(","), 'When there is one than more instane of traderbot, pass their ids(coma separated)')
        stringParam('TIMEOUT', '15', 'Number of minutes after which the job will stop')
        stringParam('JENKINS_SHARED_LIB_BRANCH', 'main', 'Branch of jenkins-shared-library from which pipeline should be run')
        stringParam('NODE_LABEL', args.get('NODE_LABEL', 'tiny'), 'Jenkins label for running pipeline (empty means any node)')
    }
}

def networkApplyNonRestartChangesParams(args=[:]) {

    List nodesList = ['All'] + (0..9).collect { "n${it.toString().padLeft( 2, '0' )}.${args.name}.vega.rocks" } + [
        "be.${args.name}.vega.rocks",
        "be02.${args.name}.vega.rocks",
        "metabase00.${args.name}.vega.rocks",
        "metabase01.${args.name}.vega.rocks",
    ]

    if (args.name == "mainnet") {
        nodesList = [
            'All',
            "api0.vega.community",
            "api1.vega.community",
            "api3.vega.community",
            "api4.vega.community",
            "api5.vega.community",
            "be0.vega.community",
            "be1.vega.community",
            "be3.vega.community",
            "m0.vega.community",
            "m2.vega.community",
            "m3.vega.community",
            "m4.vega.community",
            "metabase.vega.community",
            "test.vega.community",
        ]
    }

    return {
        choiceParam('NODE', nodesList, 'Apply changes to specified node.')
        booleanParam('DRY_RUN', false, 'Run dry run without applying changes.')
        booleanParam('UPDATE_ACCOUNTS', false, 'Update ssh accounts.')
        booleanParam('DISABLE_LOCK', true, 'Allows you to run multiple jobs for specific network at the same time.')
        stringParam('TIMEOUT', '15', 'Number of minutes after which the job will stop')
        stringParam('ANSIBLE_BRANCH', 'master', 'Git branch, tag or hash of the vegaprotocol/ansible repository')
        stringParam('JENKINS_SHARED_LIB_BRANCH', 'main', 'Branch of jenkins-shared-library from which pipeline should be run')
        stringParam('NODE_LABEL', args.get('NODE_LABEL', 'tiny'), 'Jenkins label for running pipeline (empty means any node)')
    }
}

def zfsBackupParams(args=[:]) {

    List nodesList = ['All'] + (0..9).collect { "n${it.toString().padLeft( 2, '0' )}.${args.name}.vega.rocks" } + [
        "be.${args.name}.vega.rocks",
        "be02.${args.name}.vega.rocks",
        "metabase00.${args.name}.vega.rocks",
        "metabase01.${args.name}.vega.rocks",
    ]

    if (args.name == "mainnet") {
        nodesList = [
            'All',
            "api0.vega.community",
            "api1.vega.community",
            "api3.vega.community",
            "api4.vega.community",
            "api5.vega.community",
            "be0.vega.community",
            "be1.vega.community",
            "be3.vega.community",
            "m0.vega.community",
            "m2.vega.community",
            "m3.vega.community",
            "m4.vega.community",
            "metabase.vega.community",
            "test.vega.community",
        ]
    }

    return {
        choiceParam('NODE', nodesList, 'Apply changes to specified node.')
        booleanParam('DRY_RUN', false, 'Run dry run without applying changes.')
        booleanParam('CREATE_LOCAL_ZFS_SNAPSHOT', false, 'Create zfs snapshot, but not publish it anywhere')
        stringParam('CREATE_LOCAL_ZFS_SNAPSHOT_NAME', '', 'Name of the local zfs snapshot. Leave empty to get default value with timestamp in it.')
        booleanParam('CREATE_LOCAL_ZFS_SNAPSHOT_STOP_SERVICES', true, 'Stop services before taking snapshot, start them right after (if they were running).')
        stringParam('DESTROY_LOCAL_ZFS_SNAPSHOT_NAMES', '', 'Comma separated list of snapshot name prefixes to destroy. Leave empty to not destroy anything. IMPORTANT: it is not full match, but prefix match')
        stringParam('ROLLBACK_LOCAL_ZFS_SNAPSHOT_NAME', '', 'Name of the local zfs snapshot to rollback to. Leave empty to skip rollback.')
        booleanParam('ROLLBACK_LOCAL_ZFS_SNAPSHOT_START_SERVICES', true, 'Start services after rollback.')
        booleanParam('ROLLBACK_REMOTE_ZFS_SNAPSHOT', false, 'Rollback to remote snapshot')
        booleanParam('ROLLBACK_REMOTE_ZFS_SNAPSHOT_START_SERVICES', true, 'Start services after rollback.')
        stringParam('ROLLBACK_REMOTE_ZFS_SNAPSHOT_SRC_MACHINE', args.name == 'mainnet' ? 'api0.vega.community' : '', 'From which machine use backup')
        booleanParam('DISABLE_LOCK', true, 'Allows you to run multiple jobs for specific network at the same time.')
        stringParam('TIMEOUT', '15', 'Number of minutes after which the job will stop')
        stringParam('ANSIBLE_BRANCH', 'master', 'Git branch, tag or hash of the vegaprotocol/ansible repository')
        stringParam('JENKINS_SHARED_LIB_BRANCH', 'main', 'Branch of jenkins-shared-library from which pipeline should be run')
        stringParam('NODE_LABEL', args.get('NODE_LABEL', 'tiny'), 'Jenkins label for running pipeline (empty means any node)')
    }
}

def fleetUpdateMachineParams(args=[:]) {
    List machineList = [
        "prometheus.vega.rocks",
    ]

    return {
        choiceParam('MACHINE_NAME', machineList, 'Apply changes to specified machine.')
        booleanParam('DRY_RUN', false, 'Run dry run without applying changes.')
        booleanParam('UPDATE_ACCOUNTS', false, 'Update ssh accounts.')
        stringParam('TIMEOUT', '15', 'Number of minutes after which the job will stop')
        stringParam('ANSIBLE_BRANCH', 'master', 'Git branch, tag or hash of the vegaprotocol/ansible repository')
        stringParam('JENKINS_SHARED_LIB_BRANCH', 'main', 'Branch of jenkins-shared-library from which pipeline should be run')
        stringParam('NODE_LABEL', 'tiny', 'Jenkins label for running pipeline (empty means any node)')
    }
}


def systemTestsParamsGeneric(args=[:]) {
    return {
        stringParam('ORIGIN_REPO', 'vegaprotocol/vega', 'repository which acts as vega source code (used for forks builds)')
        stringParam('VEGA_BRANCH', 'develop', 'Git branch, tag or hash of the vegaprotocol/vega repository')
        stringParam('VEGA_BRANCH_UPGRADE', '', 'Git branch, tag or hash of the vegaprotocol/vega repository to build the upgrade binary. If empty upgrade binary is created from the VEGA_BRANCH')
        stringParam('SYSTEM_TESTS_BRANCH', 'develop', 'Git branch, tag or hash of the vegaprotocol/system-tests repository')
        stringParam('VEGACAPSULE_BRANCH', 'main', 'Git branch, tag or hash of the vegaprotocol/vegacapsule repository')
        stringParam('VEGATOOLS_BRANCH', 'develop', 'Git branch, tag or hash of the vegaprotocol/vegatools repository')
        stringParam('DEVOPS_INFRA_BRANCH', 'master', 'Git branch, tag or hash of the vegaprotocol/devops-infra repository')
        stringParam('DEVOPSSCRIPTS_BRANCH', 'main', 'Git branch, tag or hash of the vegaprotocol/devopsscripts repository')
        stringParam('TEST_EXTRA_PYTEST_ARGS', '', 'extra args passed to system tests execution')
        stringParam('SYSTEM_TESTS_NETWORK_PARAM_OVERRIDES', '', 'Override network parameters at the beginning of the run.')
        stringParam('DEVOPSTOOLS_BRANCH', 'main', 'Git branch, tag or hash of the vegaprotocol/devopstools repository')
        booleanParam('SYSTEM_TESTS_DEBUG', false, 'Enable debug logs for system-tests execution')
        stringParam('TIMEOUT', args.get('TIMEOUT', '900'), 'Timeout in minutes, after which the pipline is force stopped.')
        booleanParam('PRINT_NETWORK_LOGS', false, 'By default logs are only archived as as Jenkins Pipeline artifact. If this is checked, the logs will be printed in jenkins as well')
        booleanParam('RUN_PROTOCOL_UPGRADE_PROPOSAL', args.get('RUN_PROTOCOL_UPGRADE_PROPOSAL', false), 'Determines whether the post-run stage to check protocol upgrade snapshot is run')
        booleanParam('RUN_SOAK_TEST', args.get('RUN_SOAK_TEST', true), 'Determines if the SOAK test is going to run after the system-tests')
        if (args.get('SCENARIO', false)){
            choiceParam('SCENARIO', args.get('SCENARIO') == 'NIGHTLY' ? ['NIGHTLY', 'PR'] : ['PR', 'NIGHTLY'], 'Choose which scenario should be run, to see exact implementation of the scenario visit -> https://github.com/vegaprotocol/jenkins-shared-library/blob/main/vars/pipelineCapsuleSystemTests.groovy')
        }
        stringParam('JENKINS_SHARED_LIB_BRANCH', 'main', 'Branch of jenkins-shared-library from which pipeline should be run')
        stringParam('NODE_LABEL', args.get('NODE_LABEL', 'office-system-tests'), 'Jenkins label for running pipeline (empty means any node)')
    }
}

def systemTestsParamsWrapper() {
    return systemTestsParamsGeneric() << {
        stringParam('SYSTEM_TESTS_TEST_FUNCTION', '', 'Run only a tests with a specified function name. This is actually a "pytest -k $SYSTEM_TESTS_TEST_FUNCTION_NAME" command-line argument, see more: https://docs.pytest.org/en/stable/usage.html')
        stringParam('SYSTEM_TESTS_TEST_MARK', 'smoke', 'Run only a tests with the specified mark(s). This is actually a "pytest -m $SYSTEM_TESTS_TEST_MARK" command-line argument, see more: https://docs.pytest.org/en/stable/usage.html')
        stringParam('SYSTEM_TESTS_TEST_DIRECTORY', '', 'Run tests from files in this directory and all sub-directories')
        stringParam('TEST_DIRECTORY', '', 'list or wildcard of files/directories to collect test files from')
        stringParam('CAPSULE_CONFIG', 'capsule_config.hcl', 'Run tests using the given vegacapsule config file')
        booleanParam('SKIP_MULTISIGN_SETUP', false, h('When true validators are not added to multisig as signers'))
        booleanParam('ARCHIVE_VEGA_BINARY', false, 'Define if vega binary needs to be archived - requirement for soak test pipelines')
    }
}

def lnlSystemTestsparams(Map args=[:]) {
    return systemTestsParamsGeneric(args) << {
        stringParam('SYSTEM_TESTS_TEST_FUNCTION', 'test_checkpoint_loaded', 'Run only a tests with a specified function name. This is actually a "pytest -k $SYSTEM_TESTS_TEST_FUNCTION_NAME" command-line argument, see more: https://docs.pytest.org/en/stable/usage.html')
        stringParam('SYSTEM_TESTS_TEST_MARK', '', 'Run only a tests with the specified mark(s). This is actually a "pytest -m $SYSTEM_TESTS_TEST_MARK" command-line argument, see more: https://docs.pytest.org/en/stable/usage.html')
        stringParam('SYSTEM_TESTS_TEST_DIRECTORY', 'tests/LNL', 'Run tests from files in this directory and all sub-directories')
        stringParam('CAPSULE_CONFIG', 'capsule_config_mainnet.hcl', 'Run tests using the given vegacapsule config file')
        booleanParam('SKIP_MULTISIGN_SETUP', true, h('When true validators are not added to multisig as signers'))
    }
}

def snapshotCompatibilityParams(Map args=[:]) {
    return systemTestsParamsGeneric(args) << {
        stringParam('SYSTEM_TESTS_TEST_FUNCTION', '', 'Run only a tests with a specified function name. This is actually a "pytest -k $SYSTEM_TESTS_TEST_FUNCTION_NAME" command-line argument, see more: https://docs.pytest.org/en/stable/usage.html')
        stringParam('SYSTEM_TESTS_TEST_MARK', '', 'Run only a tests with the specified mark(s). This is actually a "pytest -m $SYSTEM_TESTS_TEST_MARK" command-line argument, see more: https://docs.pytest.org/en/stable/usage.html')
        stringParam('SYSTEM_TESTS_TEST_DIRECTORY', 'tests/snapshot_compatibility', 'Run tests from files in this directory and all sub-directories')
        stringParam('CAPSULE_CONFIG', 'capsule_config_mainnet_snapshot.hcl', 'Run tests using the given vegacapsule config file')
    }
}



def approbationParams(def config=[:]) {
    return {
        if (config.type == 'core') {
            stringParam('ORIGIN_REPO', 'vegaprotocol/vega', 'repo which acts as source of vegaprotocol (used for forks builds)')
            stringParam('VEGA_CORE_BRANCH', 'develop', 'Git branch, tag or hash of the origin repo repository')
            stringParam('MULTISIG_CONTROL_BRANCH', 'develop', 'Git branch, tag or hash of the vegaprotocol/MultisigControl repository')
            stringParam('VEGA_TOKEN_V2_BRANCH', 'main', 'Git branch, tag or hash of the vegaprotocol/Vega_Token_V2 repository')
            stringParam('STAKING_BRIDGE_BRANCH', 'main', 'Git branch, tag or hash of the vegaprotocol/Staking_Bridge repository')
            stringParam('SYSTEM_TESTS_BRANCH', 'develop', 'Git branch, tag or hash of the vegaprotocol/system-tests repository')
        }
        else if (config.type == 'frontend') {
            stringParam('FRONTEND_BRANCH', 'develop', 'Git branch, tag or hash of the vegaprotocol/frontend-monorepo repository')
            stringParam('VEGAWALLET_DESKTOP_BRANCH', 'develop', 'Git branch, tag or hash of the vegaprotocol/vegawallet-desktop repository')
            stringParam('VEGAWALLET_UI_BRANCH', 'develop', 'Git branch, tag or hash of the vegaprotocol/vegawallet-ui repository')
            stringParam('CONSOLE_TEST_BRANCH', 'main', 'Git branch, tag or hash of the vegaprotocol/console-test repository')

        }
        else if(config.type == 'browserWallet') {
            stringParam('VEGAWALLET_BROWSER_BRANCH', 'main', 'Git branch, tag or hash of the vegaprotocol/vegawallet-browser repository')
        }

        stringParam('APPROBATION_TAG', 'v4.5.1', 'Approbation image tag. latest or specific version with v prefix')

        stringParam('SPECS_BRANCH', 'cosmicelevator', 'Git branch, tag or hash of the vegaprotocol/specs repository')

        if (config.type == 'core') {
            stringParam('SPECS_ARG', '{/workspace/specs/protocol/**/*.{md,ipynb},/workspace/specs/non-protocol-specs/**/*.{md,ipynb}}', '--specs argument value')
        }
        else if (config.type == 'frontend') {
            stringParam('SPECS_ARG', '/workspace/frontend-monorepo/specs/**/*.md', '--specs argument value')
        }
        else if (config.type == 'browserWallet') {
            stringParam('SPECS_ARG', '/workspace/vegawallet-browser/specs/**/*.md', '--specs argument value')
        }

        if (config.type == 'core') {
            stringParam('CATEGORIES_ARG', '/workspace/specs/protocol/categories.json', '--categories argument value')
        }
        else if (config.type == 'frontend') {
            stringParam('CATEGORIES_ARG', '/workspace/frontend-monorepo/specs/categories.json', '--categories argument value for the categories run')
            stringParam('APPS_ARG', '/workspace/frontend-monorepo/specs/apps.json', '--categories argument value for the apps run')
        }

        else if (config.type == 'browserWallet') {
            stringParam('CATEGORIES_ARG', '/workspace/vegawallet-browser/specs/categories.json', '--categories argument value for the categories run')
            stringParam('APPS_ARG', '/workspace/vegawallet-browser/specs/apps.json', '--categories argument value for the apps run')
        }

        if (config.type == 'core') {
            stringParam('FEATURES_ARG',  '/workspace/specs/protocol/features.json', '--features argument value')
        }
        else if (config.type == 'frontend' || config.type == 'browserWallet') {
            stringParam('FEATURES_ARG',  '', '--features argument value')
        }

        if (config.type == 'core') {
            stringParam('TESTS_ARG',  '{/workspace/system-tests/tests/**/*.py,/workspace/vega/core/integration/**/*.{go,feature},/workspace/MultisigControl/test/*.js,/workspace/Vega_Token_V2/test/*.js,/workspace/Staking_Bridge/test/*.js}', '--tests argument value')
        }
        else if (config.type == 'frontend') {
            stringParam('TESTS_ARG', '{/workspace/frontend-monorepo/apps/*-e2e/**/*.cy.{ts,js,tsx,jsx},/workspace/vegawallet-desktop/frontend/automation/e2e/**/*.test.{ts,js,tsx,jsx},/workspace/vegawallet-ui/apps/wallet-mock/src/test/**/*.test.{ts,js,tsx,jsx},/workspace/console-test/tests/**/*.py}', '--tests argument value')
        }
        else if (config.type == 'browserWallet') {
            stringParam('TESTS_ARG', '/workspace/vegawallet-browser/{frontend,test,web-extension}/**/*.spec.{ts,js,tsx,jsx}', '--tests argument value')
        }

        if (config.type == 'core' ) {
            stringParam('IGNORE_ARG','{/workspace/spec-internal/protocol/0060*,/workspace/specs/non-protocol-specs/{0001-NP*,0002-NP*,0004-NP*,0006-NP*,0007-NP*,0008-NP*,0010-NP*}}', '--ignore argument value' )
        }

        if (config.type == 'core') {
            stringParam('OTHER_ARG', '--show-branches --show-mystery --category-stats --show-files --verbose --output-csv --output-jenkins --show-file-stats',  'Other arguments')
        }
        else if (config.type == 'frontend' || config.type == 'browserWallet') {
            stringParam('OTHER_ARG', '--category-stats --show-branches --verbose --show-files --output-jenkins  --output-csv', 'Other arguments')
        }

        stringParam('JENKINS_SHARED_LIB_BRANCH', 'main', 'Branch of jenkins-shared-library from which pipeline should be run')
        stringParam('NODE_LABEL', config.get('NODE_LABEL', 'tiny'), 'Jenkins label for running pipeline (empty means any node)')
    }
}

def snapshotParams(args=[:]) {
    return {
        stringParam('TIMEOUT', args.get('TIMEOUT', '10'), 'Number of minutes after which the node will stop')
        booleanParam('BACKUP_SNAPSHOTS', false, 'Backup the latest snapshots in the vegaprotocol/snapshot-backups repository')
        stringParam('JENKINS_SHARED_LIB_BRANCH', 'main', 'Branch of jenkins-shared-library from which pipeline should be run')
        stringParam('NODE_LABEL', args.get('NODE_LABEL', 'cloud-machine'), 'Jenkins label for running pipeline (empty means any node)')
    }
}


def jobs = [
    // DSL Job - the one that manages this file
    [
        name: 'private/jenkins/DSL Job',
        numToKeep: 50,
        repo: 'jenkins-shared-library',
        description: h('this job is used to generate other jobs'),
        jenkinsfile: 'dsl/Jenkinsfile',
        branch: 'main',
        disableConcurrentBuilds: true,

        check: 'DSL Job',
    ],
    // Jenkins Configuration As Code
    [
        name: 'private/jenkins/Jenkins Configuration as Code Pipeline',
        numToKeep: 50,
        check: 'Jenkins Configuration as Code pipeline',
        repo: 'jenkins-shared-library',
        description: h('This job is used to auto apply changes to jenkins instance configuration'),
        jenkinsfile: 'jcasc/Jenkinsfile',
        branch: 'main',
        disableConcurrentBuilds: true,
    ],
    [
        name: 'private/jenkins/proxmox-provisioner',
        numToKeep: 50,
        repo: 'ansible',
        description: h('This job is used to auto apply changes done to the jenkins-agent role'),
        jenkinsfile: 'Jenkinsfile',
        branch: 'master',
        disableConcurrentBuilds: false,
        parameters: {
            stringParam('NODE', '', 'define on which node run provision, if empty - all nodes will be used, if you want multiple seperate them with ","')
            booleanParam('DRY_RUN', false, 'Run dry run without applying changes.')
            stringParam('JENKINS_SHARED_LIB_BRANCH', 'main', 'Branch of jenkins-shared-library from which pipeline should be run')
            stringParam('ANSIBLE_BRANCH', 'master', 'Git branch, tag or hash of the vegaprotocol/ansible repository')
        }
    ],
    [
        name: 'private/Deployments/Publish-vega-dev-releases',
        numToKeep: 200,
        description: h('This job builds vega binaries and publishes then as GitHub release to vega-dev-releases GitHub repo'),
        useScmDefinition: false,
        definition: libDefinition('pipelineVegaDevRelease()'),
        parameters: {
            stringParam('VEGA_VERSION', 'develop', 'Git branch, tag or hash of the vegaprotocol/vega repository')
            booleanParam('DEPLOY_TO_DEVNET_1', true, 'Trigger deployment to Devnet 1')
            booleanParam('DEPLOY_TO_STAGNET_1', false, 'Trigger deployment to Stagnet 1')
            stringParam('RELEASE_VERSION_OVERRIDE', '', 'Define version override. If not empty this version is used in the binary version and for the release name in the vega-dev-releases repository')
            stringParam('JENKINS_SHARED_LIB_BRANCH', 'main', 'Branch of jenkins-shared-library from which pipeline should be run')
            stringParam('NODE_LABEL', 'core-build', 'Jenkins label for running pipeline (empty means any node)')
        },
        disableConcurrentBuilds: true,
    ],
    //
    // Devnet 1
    //
    [
        name: 'private/Deployments/devnet1/Manage-Network',
        numToKeep: 100,
        description: devopsInfraDocs,
        useScmDefinition: false,
        definition: libDefinition('pipelineVegavisorManageNetwork()'),
        env: [
            NET_NAME: 'devnet1',
            ANSIBLE_LIMIT: 'devnet1',
            ANSIBLE_PLAYBOOK: 'playbook-barenode.yaml',
            ANSIBLE_PLAYBOOK_COMMON: 'playbook-barenode-common.yaml',
            ANSIBLE_PLAYBOOK_NON_RESTART_REQUIRED: 'playbook-barenode-non-restart-required.yaml',
        ],
        parameters: vegavisorRestartNetworkParams(
            TOP_UP_BOTS: true,
            USE_CHECKPOINT: false,
            CREATE_MARKETS: true,
        ),
        disableConcurrentBuilds: true,
    ],
    [
        name: 'private/Deployments/devnet1/Manage-Node',
        numToKeep: 100,
        description: vegavisorManageNodeDescription(),
        useScmDefinition: false,
        definition: libDefinition('pipelineVegavisorManageNode()'),
        env: [
            NET_NAME: 'devnet1',
            ANSIBLE_PLAYBOOK: 'playbook-barenode.yaml',
            ANSIBLE_PLAYBOOK_COMMON: 'playbook-barenode-common.yaml',
            ANSIBLE_PLAYBOOK_NON_RESTART_REQUIRED: 'playbook-barenode-non-restart-required.yaml',
        ],
        parameters: vegavisorManageNodeParams(
            name: 'devnet1',
        ),
        disableConcurrentBuilds: false,
        parameterizedCron: [
            // restart a random node every 1 hour
            '20 * * * * %' + ['RANDOM_NODE=true'].join(';'),
            // validator joining & leaving every 1 hour
            '50 * * * * %' + [
                'ACTION=create-node',
                'UNSAFE_RESET_ALL=true',
                'JOIN_AS_VALIDATOR=true',
                'USE_REMOTE_SNAPSHOT=true',
                'NODE=n05.devnet1.vega.rocks'
            ].join(';'),
        ].join('\n'),
    ],
    [
        name: 'private/Deployments/devnet1/Protocol-Upgrade',
        numToKeep: 100,
        useScmDefinition: false,
        definition: libDefinition('pipelineVegavisorProtocolUpgradeNetwork()'),
        env: [
            NET_NAME: 'devnet1',
            ANSIBLE_LIMIT: 'devnet1',
        ],
        parameters: vegavisorProtocolUpgradeParams(),
        disableConcurrentBuilds: true,
    ],
    [
        name: 'private/Deployments/devnet1/Topup-Bots',
        numToKeep: 100,
        useScmDefinition: false,
        definition: libDefinition('pipelineVegavisorTopupBots()'),
        env: [
            NET_NAME: 'devnet1',
            RESEARCH_BOT: true,
        ],
        parameters: vegavisorTopupBotsParams(),
        cron: '0 H/2 * * *',
        disableConcurrentBuilds: true,
    ],
    [
        name: 'private/Deployments/devnet1/Non-Restart-Changes',
        numToKeep: 100,
        description: 'Apply changes not requiring restarting a node or network',
        useScmDefinition: false,
        definition: libDefinition('pipelineNetworkApplyNonRestartChanges()'),
        env: [
            NET_NAME: 'devnet1',
            ANSIBLE_PLAYBOOK: 'playbook-barenode-non-restart-required.yaml',
        ],
        parameters: networkApplyNonRestartChangesParams(
            name: 'devnet1',
        ),
        disableConcurrentBuilds: false,
    ],
    [
        name: 'private/Deployments/devnet1/zfs-backup',
        numToKeep: 100,
        description: 'Perform zfs backup or restore tasks',
        useScmDefinition: false,
        definition: libDefinition('pipelineZfsBackup()'),
        env: [
            NET_NAME: 'devnet1',
        ],
        parameters: zfsBackupParams(
            name: 'devnet1',
        ),
        disableConcurrentBuilds: false,
    ],
    //
    // Stagnet 1
    //
    [
        name: 'private/Deployments/stagnet1/Manage-Network',
        numToKeep: 100,
        description: devopsInfraDocs,
        useScmDefinition: false,
        definition: libDefinition('pipelineVegavisorManageNetwork()'),
        env: [
            NET_NAME: 'stagnet1',
            ANSIBLE_LIMIT: 'stagnet1',
            ANSIBLE_PLAYBOOK: 'playbook-barenode.yaml',
            ANSIBLE_PLAYBOOK_COMMON: 'playbook-barenode-common.yaml',
            ANSIBLE_PLAYBOOK_NON_RESTART_REQUIRED: 'playbook-barenode-non-restart-required.yaml',
        ],
        parameters: vegavisorRestartNetworkParams(),
        disableConcurrentBuilds: true,
    ],
    [
        name: 'private/Deployments/stagnet1/Manage-Node',
        numToKeep: 100,
        description: vegavisorManageNodeDescription(),
        useScmDefinition: false,
        definition: libDefinition('pipelineVegavisorManageNode()'),
        env: [
            NET_NAME: 'stagnet1',
            ANSIBLE_PLAYBOOK: 'playbook-barenode.yaml',
            ANSIBLE_PLAYBOOK_COMMON: 'playbook-barenode-common.yaml',
            ANSIBLE_PLAYBOOK_NON_RESTART_REQUIRED: 'playbook-barenode-non-restart-required.yaml',
        ],
        parameters: vegavisorManageNodeParams(
            name: 'stagnet1',
        ),
        disableConcurrentBuilds: false,
        // restart a random node every 30min
        //parameterizedCron: 'H/30 * * * * %RANDOM_NODE=true',
    ],
    [
        name: 'private/Deployments/stagnet1/Protocol-Upgrade',
        numToKeep: 100,
        useScmDefinition: false,
        definition: libDefinition('pipelineVegavisorProtocolUpgradeNetwork()'),
        env: [
            NET_NAME: 'stagnet1',
            ANSIBLE_LIMIT: 'stagnet1',
        ],
        parameters: vegavisorProtocolUpgradeParams(),
        disableConcurrentBuilds: true,
    ],
    [
        name: 'private/Deployments/stagnet1/Topup-Bots',
        numToKeep: 100,
        useScmDefinition: false,
        definition: libDefinition('pipelineVegavisorTopupBots()'),
        env: [
            NET_NAME: 'stagnet1',
        ],
        parameters: vegavisorTopupBotsParams(),
        cron: 'H * * * *',
        disableConcurrentBuilds: true,
    ],
    [
        name: 'private/Deployments/stagnet1/Non-Restart-Changes',
        numToKeep: 100,
        description: 'Apply changes not requiring restarting a node or network',
        useScmDefinition: false,
        definition: libDefinition('pipelineNetworkApplyNonRestartChanges()'),
        env: [
            NET_NAME: 'stagnet1',
            ANSIBLE_PLAYBOOK: 'playbook-barenode-non-restart-required.yaml',
        ],
        parameters: networkApplyNonRestartChangesParams(
            name: 'stagnet1',
        ),
        disableConcurrentBuilds: false,
    ],
    [
        name: 'private/Deployments/stagnet1/zfs-backup',
        numToKeep: 100,
        description: 'Perform zfs backup or restore tasks',
        useScmDefinition: false,
        definition: libDefinition('pipelineZfsBackup()'),
        env: [
            NET_NAME: 'stagnet1',
        ],
        parameters: zfsBackupParams(
            name: 'stagnet1',
        ),
        disableConcurrentBuilds: false,
    ],
    //
    // Mainnet Mirror
    //
    [
        name: 'private/Deployments/mainnet-mirror/Manage-Network',
        numToKeep: 100,
        description: devopsInfraDocs,
        useScmDefinition: false,
        definition: libDefinition('pipelineVegavisorManageNetwork()'),
        env: [
            NET_NAME: 'mainnet-mirror',
            ANSIBLE_LIMIT: 'mainnet-mirror',
            ANSIBLE_PLAYBOOK: 'playbook-barenode71.yaml',
            ANSIBLE_PLAYBOOK_COMMON: 'playbook-barenode71-common.yaml',
            ANSIBLE_PLAYBOOK_NON_RESTART_REQUIRED: 'playbook-barenode71-non-restart-required.yaml',
        ],
        parameters: vegavisorRestartNetworkParams(),
        disableConcurrentBuilds: true,
    ],
    [
        name: 'private/Deployments/mainnet-mirror/Manage-Node',
        numToKeep: 100,
        description: vegavisorManageNodeDescription(),
        useScmDefinition: false,
        definition: libDefinition('pipelineNetworkManageNode71()'),
        env: [
            NET_NAME: 'mainnet-mirror',
            ANSIBLE_PLAYBOOK: 'playbook-barenode71.yaml',
            ANSIBLE_PLAYBOOK_COMMON: 'playbook-barenode71-common.yaml',
            ANSIBLE_PLAYBOOK_NON_RESTART_REQUIRED: 'playbook-barenode71-non-restart-required.yaml',
        ],
        parameters: vegavisorManageNodeParams(
            name: 'mainnet-mirror',
        ),
        disableConcurrentBuilds: false,
        // restart a random node every 30min
        //parameterizedCron: 'H/30 * * * * %RANDOM_NODE=true',
    ],
    [
        name: 'private/Deployments/mainnet-mirror/Topup-Bots',
        numToKeep: 100,
        useScmDefinition: false,
        definition: libDefinition('pipelineVegavisorTopupBots()'),
        env: [
            NET_NAME: 'mainnet-mirror',
        ],
        parameters: vegavisorTopupBotsParams(),
        cron: 'H */6 * * *',
        disableConcurrentBuilds: true,
    ],
    [
        name: 'private/Deployments/mainnet-mirror/Non-Restart-Changes',
        numToKeep: 100,
        description: 'Apply changes not requiring restarting a node or network',
        useScmDefinition: false,
        definition: libDefinition('pipelineNetworkApplyNonRestartChanges()'),
        env: [
            NET_NAME: 'mainnet-mirror',
            ANSIBLE_PLAYBOOK: 'playbook-barenode-non-restart-required.yaml',
        ],
        parameters: networkApplyNonRestartChangesParams(
            name: 'mainnet-mirror',
        ),
        disableConcurrentBuilds: false,
    ],
    [
        name: 'private/Deployments/mainnet-mirror/zfs-backup',
        numToKeep: 100,
        description: 'Perform zfs backup or restore tasks',
        useScmDefinition: false,
        definition: libDefinition('pipelineZfsBackup()'),
        env: [
            NET_NAME: 'mainnet-mirror',
        ],
        parameters: zfsBackupParams(
            name: 'mainnet-mirror',
        ),
        disableConcurrentBuilds: false,
    ],
    [
        name: 'private/Deployments/mainnet-mirror/Protocol-Upgrade',
        numToKeep: 100,
        useScmDefinition: false,
        definition: libDefinition('pipelineVegavisorProtocolUpgradeNetwork()'),
        env: [
            NET_NAME: 'mainnet-mirror',
            ANSIBLE_LIMIT: 'mainnet-mirror',
        ],
        parameters: vegavisorProtocolUpgradeParams(),
        disableConcurrentBuilds: true,
    ],
    //
    // Fairground
    //
    [
        name: 'private/Deployments/fairground/Manage-Network',
        numToKeep: 100,
        description: devopsInfraDocs,
        useScmDefinition: false,
        definition: libDefinition('pipelineVegavisorManageNetwork()'),
        env: [
            NET_NAME: 'fairground',
            ANSIBLE_LIMIT: 'fairground',
            ANSIBLE_PLAYBOOK: 'playbook-barenode.yaml',
            ANSIBLE_PLAYBOOK_COMMON: 'playbook-barenode-common.yaml',
            ANSIBLE_PLAYBOOK_NON_RESTART_REQUIRED: 'playbook-barenode-non-restart-required.yaml',
        ],
        parameters: vegavisorRestartNetworkParams(
            USE_CHECKPOINT: true,
        ),
        disableConcurrentBuilds: true,
    ],
    [
        name: 'private/Deployments/fairground/Manage-Node',
        numToKeep: 100,
        description: vegavisorManageNodeDescription(),
        useScmDefinition: false,
        definition: libDefinition('pipelineVegavisorManageNode()'),
        env: [
            NET_NAME: 'fairground',
            ANSIBLE_PLAYBOOK: 'playbook-barenode.yaml',
            ANSIBLE_PLAYBOOK_COMMON: 'playbook-barenode-common.yaml',
            ANSIBLE_PLAYBOOK_NON_RESTART_REQUIRED: 'playbook-barenode-non-restart-required.yaml',
        ],
        parameters: vegavisorManageNodeParams(
            name: 'testnet',
        ),
        disableConcurrentBuilds: false,
        // restart a random node every 30min
        // parameterizedCron: 'H/30 * * * * %RANDOM_NODE=true',
    ],
    [
        name: 'private/Deployments/fairground/Protocol-Upgrade',
        numToKeep: 100,
        useScmDefinition: false,
        definition: libDefinition('pipelineVegavisorProtocolUpgradeNetwork()'),
        env: [
            NET_NAME: 'fairground',
            ANSIBLE_LIMIT: 'fairground',
        ],
        parameters: vegavisorProtocolUpgradeParams(),
        disableConcurrentBuilds: true,
    ],
    [
        name: 'private/Deployments/fairground/Topup-Bots',
        numToKeep: 100,
        useScmDefinition: false,
        definition: libDefinition('pipelineVegavisorTopupBots()'),
        env: [
            NET_NAME: 'fairground',
        ],
        parameters: vegavisorTopupBotsParams(),
        cron: 'H/30 * * * *',
        disableConcurrentBuilds: true,
    ],
    [
        name: 'private/Deployments/fairground/Non-Restart-Changes',
        numToKeep: 100,
        description: 'Apply changes not requiring restarting a node or network',
        useScmDefinition: false,
        definition: libDefinition('pipelineNetworkApplyNonRestartChanges()'),
        env: [
            NET_NAME: 'fairground',
            ANSIBLE_PLAYBOOK: 'playbook-barenode-non-restart-required.yaml',
        ],
        parameters: networkApplyNonRestartChangesParams(
            name: 'testnet',
        ),
        disableConcurrentBuilds: false,
    ],
    [
        name: 'private/Deployments/fairground/zfs-backup',
        numToKeep: 100,
        description: 'Perform zfs backup or restore tasks',
        useScmDefinition: false,
        definition: libDefinition('pipelineZfsBackup()'),
        env: [
            NET_NAME: 'fairground',
        ],
        parameters: zfsBackupParams(
            name: 'fairground',
        ),
        disableConcurrentBuilds: false,
    ],
    //
    // Validators-Testnet
    //
    [
        name: 'private/Deployments/validators-testnet/Manage-Node-v0-68',
        numToKeep: 100,
        description: vegavisorManageNodeDescription(),
        useScmDefinition: false,
        definition: libDefinition('pipelineVegavisorManageNode()'),
        env: [
            NET_NAME: 'validators-testnet',
            ANSIBLE_PLAYBOOK: 'playbook-barenode.yaml',
            ANSIBLE_PLAYBOOK_COMMON: 'playbook-barenode-common.yaml',
            ANSIBLE_PLAYBOOK_NON_RESTART_REQUIRED: 'playbook-barenode-non-restart-required.yaml',
        ],
        parameters: vegavisorManageNodeParams(
            name: 'validators-testnet',
            sentryNodes: true,
        ),
        disableConcurrentBuilds: false,
    ],
    [
        name: 'private/Deployments/validators-testnet/Non-Restart-Changes',
        numToKeep: 100,
        description: 'Apply changes not requiring restarting a node or network',
        useScmDefinition: false,
        definition: libDefinition('pipelineNetworkApplyNonRestartChanges()'),
        env: [
            NET_NAME: 'validators-testnet',
            ANSIBLE_PLAYBOOK: 'playbook-barenode-non-restart-required.yaml',
        ],
        parameters: networkApplyNonRestartChangesParams(
            name: 'validators-testnet',
        ),
        disableConcurrentBuilds: false,
    ],
    [
        name: 'private/Deployments/validators-testnet/zfs-backup',
        numToKeep: 100,
        description: 'Perform zfs backup or restore tasks',
        useScmDefinition: false,
        definition: libDefinition('pipelineZfsBackup()'),
        env: [
            NET_NAME: 'validators-testnet',
        ],
        parameters: zfsBackupParams(
            name: 'validators-testnet',
        ),
        disableConcurrentBuilds: false,
    ],
    //
    // Mainnet
    //
    [
        name: 'private/Deployments/mainnet/Manage-Node-71',
        numToKeep: 500,
        description: vegavisorManageNodeDescription(),
        useScmDefinition: false,
        definition: libDefinition('pipelineNetworkManageNode71()'),
        env: [
            NET_NAME: 'mainnet',
            ANSIBLE_PLAYBOOK: 'playbook-barenode71.yaml',
            ANSIBLE_PLAYBOOK_COMMON: 'playbook-barenode71-common.yaml',
            ANSIBLE_PLAYBOOK_NON_RESTART_REQUIRED: 'playbook-barenode71-non-restart-required.yaml',
        ],
        parameters: vegavisorManageNodeParams(
            name: 'mainnet',
        ),
        disableConcurrentBuilds: false,
    ],
    [
        name: 'private/Deployments/mainnet/Non-Restart-Changes',
        numToKeep: 100,
        description: 'Apply changes not requiring restarting a node or network',
        useScmDefinition: false,
        definition: libDefinition('pipelineNetworkApplyNonRestartChanges()'),
        env: [
            NET_NAME: 'mainnet',
            ANSIBLE_PLAYBOOK: 'playbook-barenode71-non-restart-required.yaml',
        ],
        parameters: networkApplyNonRestartChangesParams(
            name: 'mainnet',
        ),
        disableConcurrentBuilds: false,
    ],
    [
        name: 'private/Deployments/mainnet/Backup',
        description: devopsInfraDocs,
        useScmDefinition: false,
        definition: libDefinition('pipelineBackupNodeZFS()'),
        env: [],
        parameters: {
            stringParam('NODE_LABEL', 'tiny', 'The node label pipeline is going to run on')
            stringParam('TIMEOUT', '200', 'Global timeout in minutes')
            choiceParam('ACTION', ['BACKUP', 'RESTORE', 'LIST_BACKUPS'], 'Action to execute')
            stringParam('SERVER', '', 'Server where we are going to execute action')
            stringParam('JENKINS_SHARED_LIB_BRANCH', 'main', 'Branch of jenkins-shared-library from which pipeline should be run')
        },
        disableConcurrentBuilds: false,
        parameterizedCron: [
            // automatic backup every 6h
            'H */6 * * * %' + [
                'SERVER=api0.vega.community',
            ].join(';'),
        ].join('\n'),
    ],
    [
        name: 'private/Deployments/mainnet/zfs-backup',
        numToKeep: 100,
        description: 'Perform zfs backup or restore tasks',
        useScmDefinition: false,
        definition: libDefinition('pipelineZfsBackup()'),
        env: [
            NET_NAME: 'mainnet',
        ],
        parameters: zfsBackupParams(
            name: 'mainnet',
        ),
        disableConcurrentBuilds: false,
    ],
    //
    // Fleet
    //
    [
        name: 'private/Deployments/fleet/Update-Machine',
        numToKeep: 100,
        description: 'Apply changes from Ansible',
        useScmDefinition: false,
        definition: libDefinition('pipelineFleet()'),
        env: [
            ANSIBLE_PLAYBOOK: 'playbook-fleet.yaml',
        ],
        parameters: fleetUpdateMachineParams(),
        disableConcurrentBuilds: false,
    ],
    //
    // System-Tests
    //
    // Primary pipeline
    [
        name: 'common/system-tests-wrapper',

        useScmDefinition: false,
        definition: libDefinition('capsuleSystemTests()'),
        parameters: systemTestsParamsWrapper(),
        copyArtifacts: true,
        daysToKeep: 10,
        numToKeep: 3500,
    ],
    [
        name: 'common/system-tests-lnl-mainnet',

        useScmDefinition: false,
        definition: libDefinition('pipelineCapsuleLNL()'),
        parameters: lnlSystemTestsparams(
            NODE_LABEL: 'office-system-tests-lnl',
            RUN_PROTOCOL_UPGRADE_PROPOSAL: true,
            RUN_SOAK_TEST: false,
        ),
        copyArtifacts: true,
        daysToKeep: 10,
        cron: 'H 3 * * *',
    ],
    [
        name: 'common/system-tests-snapshot-compatibility',
        useScmDefinition: false,
        definition: libDefinition('pipelineCapsuleSnapshotCompatibility()'),
        parameters: snapshotCompatibilityParams(),
        copyArtifacts: true,
        daysToKeep: 10,
        cron: 'H 2 * * *',
    ],
    [
        name: 'common/system-tests',

        description: 'This job is just a functional wrapper over techincal call of old system-tests job. If you wish to trigger specific system-tests run go to https://jenkins.ops.vega.xyz/job/common/job/system-tests-wrapper/',
        useScmDefinition: false,
        definition: libDefinition('pipelineCapsuleSystemTests()'),
        parameters: systemTestsParamsGeneric('SCENARIO': 'PR'),
        copyArtifacts: true,
        daysToKeep: 10,
    ],
    // Primary pipeline
    [
        name: 'common/system-tests-nightly',
        description: 'This job is executed every 24h to ensure stability of the system',
        useScmDefinition: false,
        definition: libDefinition('pipelineCapsuleSystemTests()'),
        parameters: systemTestsParamsGeneric('SCENARIO': 'NIGHTLY', 'TIMEOUT': '1800'),
        copyArtifacts: true,
        daysToKeep: 10,
        cron: 'H 0 * * *',
    ],
    //
    // Vegavisor automatic download and PUP
    //
    [
        name: 'common/visor-autoinstall-and-pup',

        description: 'Job starts the network, perform protocol upgrade and waits until new binaries are automatically downloaded and network is upgraded',
        useScmDefinition: false,
        definition: libDefinition('pipelineVegavisorPupAutomaticDownload()'),
        parameters: {
            stringParam('RELEASES_REPO', 'vegaprotocol/vega-dev-releases-system-tests', 'repository where we keep all our releases for vega')
            stringParam('VEGA_BRANCH', 'develop', 'git branch, tag or hash of the vegaprotocol/vega repository')
            stringParam('SYSTEM_TESTS_BRANCH', 'develop', 'git branch, tag or hash of the vegaprotocol/system-tests repository')
            stringParam('VEGATOOLS_BRANCH', 'develop', 'git branch, tag or hash of the vegaprotocol/vegatools repository')
            stringParam('VEGACAPSULE_BRANCH', 'main', 'git branch, tag or hash of the vegaprotocol/vegacapsule repository')
            stringParam('DEVOPSSCRIPTS_BRANCH', 'main', 'git branch, tag or hash of the vegaprotocol/devopsscripts repository')
            booleanParam('CREATE_RELEASE', true, 'If true, the temporary release is created in the "RELEASE_REPO", otherwise we use last two releases from the above repository - one before last to start the network and latest to upgrade network to')
            stringParam('JENKINS_SHARED_LIB_BRANCH', 'main', 'Branch of jenkins-shared-library from which pipeline should be run')
            stringParam('NODE_LABEL', 'office-system-tests', 'Jenkins label for running pipeline (empty means any node)')
        },
        copyArtifacts: true,
        daysToKeep: 14,
        cron: 'H 0 * * *',
    ],
    //
    // Vega Market Simulator
    //
    [
        name: 'common/vega-market-sim',
        description: 'Simulate Markets on fully controllable Simulator of Vega Network',
        useScmDefinition: false,
        definition: libDefinition('pipelineVegaMarketSim()'),
        parameters: {
            stringParam('ORIGIN_REPO', 'vegaprotocol/vega', 'repository which acts as vega source code (used for forks builds)')
            stringParam('VEGA_VERSION', 'develop', 'Git branch, tag or hash of the vegaprotocol/vega repository')
            stringParam('VEGACAPSULE_VERSION', 'main', 'Git branch, tag or hash of the vegaprotocol/vegacapsule repository')
            stringParam('VEGA_MARKET_SIM_BRANCH', 'develop', 'Git branch, tag or hash of the vegaprotocol/vega-market-sim repository')
            stringParam('TIMEOUT', '45', 'Number of minutes after which the job will stop')
            stringParam('TEST_FUNCTION', '', 'Defines specified functions to run(specifies value for the pytest -k param)')
            stringParam('PARALLEL_WORKERS', '10', 'Defines number of parallel tests (specifies value for the pytest -n param)')
            stringParam('LOG_LEVEL', 'INFO', 'Log level for the pytest (INFO,DEBUG,WARN,ERROR)')
            booleanParam('RUN_EXTRA_TESTS', false, 'Run extra tests that you don\'t always want to run')
            booleanParam('RUN_LEARNING', false, 'Run a long reinforcement learning test')
            stringParam('JENKINS_SHARED_LIB_BRANCH', 'main', 'Branch of jenkins-shared-library from which pipeline should be run')
            stringParam('NODE_LABEL', 'vega-market-sim', 'Jenkins label for running pipeline (empty means any node)')
        },
        copyArtifacts: true,
        daysToKeep: 5,
    ],
    [
        name: 'common/vega-market-sim-reinforcement',
        description: 'Simulate Markets on fully controllable Simulator of Vega Network - Reinforcement learning tests',
        useScmDefinition: false,
        definition: libDefinition('pipelineVegaMarketSim()'),
        parameters: {
            stringParam('ORIGIN_REPO', 'vegaprotocol/vega', 'repository which acts as vega source code (used for forks builds)')
            stringParam('VEGA_VERSION', 'develop', 'Git branch, tag or hash of the vegaprotocol/vega repository')
            stringParam('VEGACAPSULE_VERSION', 'main', 'Git branch, tag or hash of the vegaprotocol/vegacapsule repository')
            stringParam('VEGA_MARKET_SIM_BRANCH', 'develop', 'Git branch, tag or hash of the vegaprotocol/vega-market-sim repository')
            stringParam('TIMEOUT', '1440', 'Number of minutes after which the job will stop')
            booleanParam('RUN_EXTRA_TESTS', false, 'Run extra tests that you don\'t always want to run')
            booleanParam('RUN_LEARNING', true, 'Run a long reinforcement learning test')
            stringParam('NUM_FUZZ_STEPS', '2880', 'Number of steps to run fuzz test for')
            stringParam('NUM_RL_ITERATIONS', '300', 'Number of iterations to run RL tests for')
            stringParam('JENKINS_SHARED_LIB_BRANCH', 'main', 'Branch of jenkins-shared-library from which pipeline should be run')
            stringParam('NODE_LABEL', 'vega-market-sim', 'Jenkins label for running pipeline (empty means any node)')
        },
        copyArtifacts: true,
        daysToKeep: 5,
        cron: 'H 0 * * *',
    ],
    // // Disabled whilst not needed
    // [
    //     name: 'common/vega-market-sim-parallel',
    //     description: 'Simulate Markets on fully controllable Simulator of Vega Network - parallel run for testing major changes',
    //     useScmDefinition: false,
    //     definition: libDefinition('pipelineVegaMarketSim()'),
    //     parameters: {
    //         stringParam('ORIGIN_REPO', 'vegaprotocol/vega', 'repository which acts as vega source code (used for forks builds)')
    //         stringParam('VEGA_VERSION', 'feature/integrate-sla-rebased-2', 'Git branch, tag or hash of the vegaprotocol/vega repository')
    //         stringParam('VEGACAPSULE_VERSION', 'main', 'Git branch, tag or hash of the vegaprotocol/vegacapsule repository')
    //         stringParam('VEGA_MARKET_SIM_BRANCH', 'parallel', 'Git branch, tag or hash of the vegaprotocol/vega-market-sim repository')
    //         stringParam('TIMEOUT', '1440', 'Number of minutes after which the job will stop')
    //         booleanParam('RUN_EXTRA_TESTS', false, 'Run extra tests that you don\'t always want to run')
    //         booleanParam('RUN_LEARNING', true, 'Run a long reinforcement learning test')
    //         stringParam('NUM_FUZZ_STEPS', '2880', 'Number of steps to run fuzz test for')
    //         stringParam('NUM_RL_ITERATIONS', '300', 'Number of iterations to run RL tests for')
    //         stringParam('JENKINS_SHARED_LIB_BRANCH', 'main', 'Branch of jenkins-shared-library from which pipeline should be run')
    //         stringParam('NODE_LABEL', 'vega-market-sim', 'Jenkins label for running pipeline (empty means any node)')
    //     },
    //     copyArtifacts: true,
    //     daysToKeep: 5,
    //     cron: 'H 0 * * *',
    // ],
    //
    // Snapshots
    //
    [
        name: 'private/Snapshots/Devnet1',
        numToKeep: 500,
        useScmDefinition: false,
        env: [
            NET_NAME: 'devnet1',
            HISTORY_KEY: 'NetworkHistory',
        ],
        parameters: snapshotParams(),
        daysToKeep: 4,
        definition: libDefinition('pipelineSnapshotTesting()'),
        cron: "H/12 * * * *",
        disableConcurrentBuilds: true,
    ],
    [
        name: 'private/Snapshots/Stagnet1',
        numToKeep: 500,
        useScmDefinition: false,
        env: [
            NET_NAME: 'stagnet1',
            HISTORY_KEY: 'NetworkHistory',
        ],
        parameters: snapshotParams(),
        daysToKeep: 4,
        definition: libDefinition('pipelineSnapshotTesting()'),
        cron: "H/12 * * * *",
        disableConcurrentBuilds: true,
    ],
    [
        name: 'private/Snapshots/mainnet-mirror',
        numToKeep: 500,
        useScmDefinition: false,
        env: [
            NET_NAME: 'mainnet-mirror',
            HISTORY_KEY: 'NetworkHistory',
        ],
        parameters: snapshotParams(),
        daysToKeep: 4,
        definition: libDefinition('pipelineSnapshotTesting()'),
        // cron: "H/12 * * * *",
        disableConcurrentBuilds: true,
    ],
    [
        name: 'private/Snapshots/Fairground',
        // disabled: true,
        numToKeep: 500,
        useScmDefinition: false,
        env: [
            NET_NAME: 'fairground',
            HISTORY_KEY: 'NetworkHistory',
        ],
        parameters: snapshotParams(),
        daysToKeep: 4,
        definition: libDefinition('pipelineSnapshotTesting()'),
        cron: "H/12 * * * *",
        disableConcurrentBuilds: true,
    ],
    [
        name: 'private/Snapshots/Validators-Testnet',
        // disabled: true,
        numToKeep: 500,
        useScmDefinition: false,
        env: [
            NET_NAME: 'validators-testnet',
            HISTORY_KEY: 'NetworkHistory',
            NODES_DENYLIST: 'n01.validators-testnet.vega.rocks'
        ],
        parameters: snapshotParams(),
        daysToKeep: 4,
        definition: libDefinition('pipelineSnapshotTesting()'),
        cron: "H/12 * * * *",
        disableConcurrentBuilds: true,
    ],
    [
        name: 'private/Snapshots/Mainnet',
        // disabled: true,
        numToKeep: 2500,
        useScmDefinition: false,
        env: [
            NET_NAME: 'mainnet',
            HISTORY_KEY: 'NetworkHistory'
        ],
        parameters: snapshotParams(),
        daysToKeep: 21,
        definition: libDefinition('pipelineSnapshotTesting()'),
        cron: "H/12 * * * *",
        disableConcurrentBuilds: true,
    ],
    // review deprecation of this job
    [
        name: 'private/Automations/Checkpoint-Backup',
        useScmDefinition: false,
        parameters: {
            booleanParam('DEVNET_1', false, 'Backup the latest checkpoint from the Devnet 1')
            booleanParam('FAIRGROUND', true, 'Backup the latest checkpoint from the Fairground network')
            booleanParam('MAINNET', true, 'Backup the latest checkpoint from the Mainnet')
            stringParam('CHECKPOINT_STORE_BRANCH', 'main', 'Git branch, tag or hash of the vegaprotocol/checkpoint-store repository')
            stringParam('JENKINS_SHARED_LIB_BRANCH', 'main', 'Branch of jenkins-shared-library from which pipeline should be run')
            stringParam('NODE_LABEL', 'tiny', 'Jenkins label for running pipeline (empty means any node)')
        },
        disableConcurrentBuilds: true,
        description: 'Backup checkpoints from different networks into vegaprotocol/checkpoint-store',
        definition: libDefinition('pipelineCheckpointBackup()'),
    ],
    // review deprecation of this job
    [
        name: 'private/Automations/Spam-orders',
        useScmDefinition: false,
        parameters: {
            choiceParam('NETWORK_NAME', ['devnet1', 'stagnet1', 'mainnet-mirror', 'fairground'], 'Network name')
            stringParam('THREADS', '4', 'Number of thread for spammers')
            stringParam('MAX_PRICE', '10000', 'Max price for single order')
            stringParam('THREAD_RATE_LIMIT', '15', 'Maximum number of orders single thread can send')
            stringParam('MARKET_ID', '', 'Market ID bots are sending orders to')
            stringParam('DURATION', '15m30s', 'Duration of stress-test')
            stringParam('DEVOPSTOOLS_VERSION', 'main', 'Branch/commit for the vegaprotocol/devopstools repository')
            stringParam('JENKINS_SHARED_LIB_BRANCH', 'main', 'Branch of jenkins-shared-library from which pipeline should be run')
            stringParam('NODE_LABEL', 'tiny', 'Jenkins label for running pipeline (empty means any node)')
        },
        //cron: 'H */2 * * *',
        description: 'Send orders which will stay in order book to the network',
        definition: libDefinition('spamOrders()'),
    ],
    //
    // Approbations
    //
    [
        name: 'common/approbation',
        numToKeep: 100,
        useScmDefinition: false,
        definition: libDefinition('pipelineApprobation(type: "core")'),
        parameters: approbationParams(type: 'core'),
        copyArtifacts: true,
    ],
    [
        name: 'common/approbation-frontend',
        numToKeep: 100,
        useScmDefinition: false,
        definition: libDefinition('pipelineApprobation(type: "frontend")'),
        parameters: approbationParams(type: 'frontend'),
        copyArtifacts: true,
    ],
     [
        name: 'common/approbation-browser-wallet',
        numToKeep: 100,
        useScmDefinition: false,
        definition: libDefinition('pipelineApprobation(type: "browserWallet")'),
        parameters: approbationParams(type: 'browserWallet'),
        copyArtifacts: true,
    ],
    // just wrapper for runApprobation.groovy
    [
        name: 'common/frontend-monorepo',
        repo: 'frontend-monorepo',
        numToKeep: 300,
        useGithub: true,
        jenkinsfile: 'Jenkinsfile',
        check: 'Approbation Pipeline',
        branch: 'develop',
        disableConcurrentBuilds: true,
        env: [
            BRANCH_NAME: 'develop',
            CHANGE_BRANCH: 'develop',
        ],
    ],
    // just wrapper for runApprobation.groovy
    [
        name: 'common/vegawallet-desktop',
        repo: 'vegawallet-desktop',
        useGithub: true,
        jenkinsfile: 'Jenkinsfile',
        branch: 'develop',
        disableConcurrentBuilds: true,
        check: 'Approbation Pipeline',
        env: [
            BRANCH_NAME: 'develop',
            CHANGE_BRANCH: 'develop',
        ],
    ],
    [
        name: 'common/vegawallet-browser',
        repo: 'vegawallet-browser',
        useGithub: true,
        jenkinsfile: 'Jenkinsfile',
        branch: 'main',
        disableConcurrentBuilds: true,
        check: 'Approbation Pipeline',
        env: [
            BRANCH_NAME: 'main',
            CHANGE_BRANCH: 'main',
        ],
    ],
    [
        name: 'common/performance-tests',

        useScmDefinition: false,
        numToKeep: 30,
        cron: '0 0 * * *',
        definition: libDefinition('pipelinePerformanceTest()'),
        parameters: {
            stringParam('VEGA_BRANCH', 'develop', 'Git branch, tag or hash of the vegaprotocol/vega repository')
            stringParam('VEGACAPSULE_BRANCH', 'main', 'Git branch, tag or hash of the vegaprotocol/vegacapsule repository')
            stringParam('VEGATOOLS_BRANCH', 'develop', 'Git branch, tag or hash of the vegaprotocol/vegatools repository')
            stringParam('PERFORMANCE_BRANCH', 'main', 'Git branch, tag or hash of the vegaprotocol/performance repository')
            stringParam('JENKINS_SHARED_LIB_BRANCH', 'main', 'Branch of jenkins-shared-library from which pipeline should be run')
            stringParam('NODE_LABEL', 'performance-tests', 'Jenkins label for running pipeline (empty means any node)')
        }
    ],
    [
        name: 'private/jenkins/agents-cleanup',
        useScmDefinition: false,
        numToKeep: 20,
        cron: 'H 0 * * *',
        definition: libDefinition('pipelineCleanupAgents()'),
        parameters: {
            stringParam('NODE', '', 'Node name (e.g jenkins01) to run cleanup on')
            stringParam('JENKINS_SHARED_LIB_BRANCH', 'main', 'Branch of jenkins-shared-library from which pipeline should be run')
        }
    ],
    [
        name: 'private/Automations/grafana-backup',
        useScmDefinition: false,
        numToKeep: 14,
        cron: 'H 0 * * *',
        definition: libDefinition('pipelineGrafanaBackup()'),
        cron: 'H 0 * * *',
        parameters: {
            stringParam('JENKINS_SHARED_LIB_BRANCH', 'main', 'Branch of jenkins-shared-library from which pipeline should be run')
        }

    ]
    // ethereum events
    // [
    //     name: 'private/Automations/Ethereum-Events/Sandbox',
    //     useScmDefinition: false,
    //     numToKeep: 100,
    //     definition: libDefinition('pipelineEthereumEvents()'),
    //     env: [
    //         NET_NAME: 'sandbox',
    //     ],
    //     cron: 'H/30 * * * *',
    //     parameters: {
    //         stringParam('NUMBER_OF_EVENTS', '20', 'Number of ethereum events to be sent by pipeline')
    //         stringParam('DEVOPSTOOLS_BRANCH', 'main', 'Git branch, tag or hash of the vegaprotocol/devopstools repository')
    //         stringParam('JENKINS_SHARED_LIB_BRANCH', 'main', 'Branch of jenkins-shared-library from which pipeline should be run')
    //         stringParam('NODE_LABEL', 'vega-market-sim', 'Jenkins label for running pipeline (empty means any node)')
    //     },
    // ],
]

// MAIN
jobs.each { job ->
    createCommonPipeline(job)
}
